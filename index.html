<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>CV</title>
        <link rel="stylesheet" href="https://cdn.shoelace.style/1.0.0-beta24/shoelace.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css">
        <link rel="stylesheet" href="main.css">
        <script id="shader-vs" type="x-shader/x-vertex">
    
            attribute vec3 aVertexPosition;

            attribute vec3 aVertexColor;
            
            uniform mat4 uMVMatrix;

            uniform mat4 uPMatrix;

            varying vec4 vertexColor;
            
            void main(void) {
                
                // To allow seeing the points drawn
                
                gl_PointSize = 5.0;
                
                // Just converting the (x,y,z) vertices to Homogeneous Coord.
                
                // And multiplying by the Projection and the Model-View matrix
                
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                
                // Converting the RGB color value to RGBA
                
                vertexColor = vec4(aVertexColor, 1.0);
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">

            precision mediump float;
            
            varying vec4 vertexColor;
            
            void main(void) {
                
                // Using the passed vertex color
                
                gl_FragColor = vertexColor;
            }

        </script>

        <!-- The JS files -->

        <!-- Some useful functions for browser compatibility -->

        <script type="text/javascript" src="utils.js"></script>

        <!-- Handling vectors and matrices -->

        <script type="text/javascript" src="maths.js"></script>

        <!-- Processing triangle mesh models -->

        <script type="text/javascript" src="models.js"></script>

        <!-- Creating the light sources -->

        <script type="text/javascript" src="lightSources.js"></script>

        <!-- WebGL code -->

        <script type="text/javascript" src="initShaders.js"></script>

        <script type="text/javascript" src="WebGL_example_25.js"></script>
        
    </head>

    <body onload="runWebGL();">
        <div class="container-fluid pad-0">
            <div class="row mar-0">
                <div class="col-4 pad-0">
                    <main id="main">
                        <h1>Ray Tracing</h1>
                        <p>In computer graphics, ray tracing is a rendering technique for generating an image by tracing the path of light as pixels in an image plane and simulating the effects of its encounters with virtual objects. The technique is capable of producing a very high degree of visual realism, usually higher than that of typical scanline rendering methods, but at a greater computational cost. This makes ray tracing best suited for applications where the image can be rendered slowly ahead of time, such as in still images and film and television visual effects, and more poorly suited for real-time applications like video games where speed is critical. Ray tracing is capable of simulating a wide variety of optical effects, such as reflection and refraction, scattering, and dispersion phenomena (such as chromatic aberration).</p>

                        <h2>Algorithm</h2>
                        <p>Optical ray tracing describes a method for producing visual images constructed in 3D computer graphics environments, with more photorealism than either ray casting or scanline rendering techniques. It works by tracing a path from an imaginary eye through each pixel in a virtual screen, and calculating the color of the object visible through it.</p>

                        <p>Scenes in ray tracing are described mathematically by a programmer or by a visual artist (typically using intermediary tools). Scenes may also incorporate data from images and models captured by means such as digital photography.</p>

                        <p>Typically, each ray must be tested for intersection with some subset of all the objects in the scene. Once the nearest object has been identified, the algorithm will estimate the incoming light at the point of intersection, examine the material properties of the object, and combine this information to calculate the final color of the pixel. Certain illumination algorithms and reflective or translucent materials may require more rays to be re-cast into the scene.</p>

                        <p>It may at first seem counterintuitive or "backwards" to send rays away from the camera, rather than into it (as actual light does in reality), but doing so is many orders of magnitude more efficient. Since the overwhelming majority of light rays from a given light source do not make it directly into the viewer's eye, a "forward" simulation could potentially waste a tremendous amount of computation on light paths that are never recorded.</p>

                        <p>Therefore, the shortcut taken in raytracing is to presuppose that a given ray intersects the view frame. After either a maximum number of reflections or a ray traveling a certain distance without intersection, the ray ceases to travel and the pixel's value is updated.</p>
                    </main>
                </div>

                <div class="col-8 pad-0">

                    <canvas id="canvas"></canvas>
                </div>
            </div>
        </div>

        

    </body>
</html>
